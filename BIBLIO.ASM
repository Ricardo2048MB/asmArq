;____________________ZONA DE LAS CONSTANTES________________________________
ESQ_SUP_IZQ EQU 0C9H
ESQ_SUP_DER EQU 0BBH
ESQ_INF_IZQ EQU 0C8H
ESQ_INF_DER EQU 0BCH
BARRA_HORIZ EQU 0CDH
T_SUPERIOR EQU 0CBH
T_INFERIOR EQU 0CAH
BARRA_VERTI EQU 0BAH
.MODEL SMALL
.STACK
.DATA
;____________________ZONA DE LOS DATOS_____________________________________
VECTOR DB 16 DUP (10H)
	DB 16 DUP (11H)
	DB 16 DUP (12H)
	DB 16 DUP (13H)
	DB 16 DUP (14H)
	DB 16 DUP (15H)
	DB 16 DUP (16H)
	DB 16 DUP (17H)
	DB 16 DUP (18H) 
	DB 16 DUP (19H)
	DB 16 DUP (1AH)
	DB 16 DUP (1BH)
	DB 16 DUP (1CH)
	DB 16 DUP (1DH)
	DB 16 DUP (1EH)
	DB 16 DUP (1FH)
.CODE
;____________________ZONA DE DEFINICION DE PROCEDIMIENTOS____________________________________________
PUBLIC IMPRIME_DECIMAL
IMPRIME_DECIMAL PROC
	PUSH AX
	PUSH CX
	PUSH DX
	PUSH SI
	MOV AX, DX
	MOV SI, 10
	XOR CX, CX
NO_ES_CERO:
	XOR DX, DX
	DIV SI
	PUSH DX
	INC CX
	OR AX, AX
	JNZ NO_ES_CERO
CICLO_ESCRIBE_DIGITO:
	POP DX
	CALL ESCRIBE_DIGITO_HEXA
	LOOP CICLO_ESCRIBE_DIGITO
	POP SI
	POP DX
	POP CX
	POP AX
	RET
IMPRIME_DECIMAL ENDP
PUBLIC IMPRIME_HEXADECIMAL
IMPRIME_HEXADECIMAL PROC
	PUSH AX
	PUSH CX
	PUSH DX
	PUSH SI
	MOV AX, DX; EL DIVIDENDO SE HALLA INICIALMENTE EN DX, NO SE PASA DIRECTAMENTE AL REGISTRO AX
	MOV SI, 16; EL DIVISOR SE CONFIGURA CON LA BASE REQUERIDA
	XOR CX, CX; PRIMERO NOS ASEGURAMOS ;309149132 DE QUE EL CONTADOR INICIA EN CERO ;309149132
NO_ES_CERO:
	XOR DX, DX; SE DEBE PONER;309149132 A CERO EL REGISTRO DE LA PARTE M√ÅS SIGNIFICATIVA DEL DIVIDENDO O EL RESIDUO
	;LA RAZON DE LO ANTERIOR ES QUE NUESTRO DIVIDENDO SIEMPRE MIDE 16 BITS, NO 32 BITS (UNICAMENTE PARA ESTE CASO)
	DIV SI; EL DIVISOR ES CONSTANTE Y MIDE 16 BITS
	PUSH DX; ESTO GUARDA EL RESTO ;309149132
	INC CX; SE AUMENTA EL NUMERO DE DIVISIONES REALIZADAS EN 1
	OR AX, AX; SE VERIFICA SI ACASO EL COCIENTE HA LLEGADO A CERO
	JNZ NO_ES_CERO
CICLO_ESCRIBE_DIGITO:
	POP DX
	CALL ESCRIBE_DIGITO_HEXA
	LOOP CICLO_ESCRIBE_DIGITO
	POP SI
	POP DX
	POP CX
	POP AX
	RET
IMPRIME_HEXADECIMAL ENDP
PUBLIC IMPRIME_BINARIO
IMPRIME_BINARIO PROC
	PUSH AX
	PUSH CX
	PUSH DX
	PUSH SI
	MOV AX, DX
	MOV SI, 2
	XOR CX, CX
NO_ES_CERO:
	XOR DX, DX
	DIV SI
	PUSH DX
	INC CX
	OR AX, AX
	JNZ NO_ES_CERO
CICLO_ESCRIBE_DIGITO:
	POP DX
	CALL ESCRIBE_DIGITO_HEXA
	LOOP CICLO_ESCRIBE_DIGITO
	POP SI
	POP DX
	POP CX
	POP AX
	RET
IMPRIME_BINARIO ENDP
PUBLIC ESCRIBE_ALFAHEXA
ESCRIBE_ALFAHEXA PROC
	PUSH CX
	PUSH DX
	MOV CX, 0FH
	MOV DL, 01
	CICLO1:
	PUSH DX
	CALL ESCRIBE_DIGITO_HEXA
	MOV DL, " ";20H
	CALL ESCRIBE_CARACTER
	POP DX
	INC DL
	LOOP CICLO1
	MOV DL, " ";20H
	CALL ESCRIBE_CARACTER
	MOV CX, 0FH
	MOV DL, 01
	CICLO2:
	CALL ESCRIBE_DIGITO_HEXA
	INC DL
	LOOP CICLO2
	POP DX	
	POP CX
	RET
ESCRIBE_ALFAHEXA ENDP
PUBLIC ESCRIBE_DIGITO_HEXA
ESCRIBE_DIGITO_HEXA PROC
	PUSH DX
	CMP DL, 10
	JAE LETRA_HEXA
	ADD DL, "0"
	JMP SHORT ESCRIBE_DIGITO
	LETRA_HEXA:
	ADD DL, "A"-10
	ESCRIBE_DIGITO:
	CALL ESCRIBE_CARACTER
	POP DX
	RET
ESCRIBE_DIGITO_HEXA ENDP
PUBLIC DALE_ENTER
DALE_ENTER PROC
	PUSH DX
	MOV DL, 10
	CALL ESCRIBE_CARACTER
	MOV DL, 13
	CALL ESCRIBE_CARACTER
	POP DX
	RET
DALE_ENTER ENDP
PUBLIC ESCRIBE_CARACTER
ESCRIBE_CARACTER PROC
	PUSH AX
	MOV AH, 02
	INT 21H
	POP AX
	RET
ESCRIBE_CARACTER ENDP
IMPRIME_CADENA PROC
	;DS:DX DEBE APUNTAR A UNA CADENA QUE TERMINE EN '$'
	MOV AH, 09H
	INT 21H
	RET
IMPRIME_CADENA ENDP
PUBLIC MUESTRA_LINEA
MUESTRA_LINEA PROC
	PUSH BX
	PUSH CX
	PUSH DX
	MOV BX, DX
	MOV CX, 16
	PUSH BX; 309149132
	MOV DL, BARRA_VERTI
	CALL ESCRIBE_CARACTER
	MOV DL, " "
	CALL ESCRIBE_CARACTER
CICLO_HEXA:
	MOV DL, VECTOR [BX]
	CALL IMPRIME_HEXADECIMAL; NOS VAMOS A QUEDAR PENDIENTES ACA MAISTRO
	MOV DL, ' '; ESTE ES EL ESPACIO ENTRE CADA NUMERO HEXADECIMAL
	CALL ESCRIBE_CARACTER
	INC BX; ESTO ES LO QUE RECORRE EL INDICE DEL VECTOR
	LOOP CICLO_HEXA
	MOV DL, BARRA_VERTI; ESTE ESPACIO ESTA ENTRE LOS NUMEROS Y SUS RESPECTIVOS CODIGOS ASCII
	CALL ESCRIBE_CARACTER
	MOV CX, 16
	POP BX; SE VUELVE A PONER A CERO BX
	MOV DL, " "
	CALL ESCRIBE_CARACTER
CICLO_ASCII:; EL SEGUNDO CICLO SIMPLEMENTE ESCRIBE LOS CARACTERES ASCII CORRESPONDIENTES
	MOV DL, VECTOR [BX]
	CALL ESCRIBE_CARACTER
	INC BX
	LOOP CICLO_ASCII
	MOV DL, " "
	CALL ESCRIBE_CARACTER
	MOV DL, BARRA_VERTI
	CALL ESCRIBE_CARACTER
	POP DX
	POP CX
	POP BX
	RET
MUESTRA_LINEA ENDP
PUBLIC DISP_MEDIO_SECTOR
DISP_MEDIO_SECTOR PROC
	MOV AX, @DATA
	MOV DS, AX
	XOR DX, DX
	MOV CX, 16	
MEDIO_SECTOR:
	CALL MUESTRA_LINEA;309149132
	CALL DALE_ENTER
	ADD DX, 16
	LOOP MEDIO_SECTOR
	RET
DISP_MEDIO_SECTOR ENDP
PUBLIC PARTE_SUPERIOR
PARTE_SUPERIOR PROC
	PUSH CX
	PUSH DX
	MOV DL, ESQ_SUP_IZQ
	CALL ESCRIBE_CARACTER
	MOV CX, 49;20
	MOV DL, BARRA_HORIZ
	CICLO:
	CALL ESCRIBE_CARACTER
	LOOP CICLO
	MOV DL, T_SUPERIOR
	CALL ESCRIBE_CARACTER
	MOV CX, 18;20
	MOV DL, BARRA_HORIZ
	CICLO2:;309149132
	CALL ESCRIBE_CARACTER
	LOOP CICLO2
	MOV DL, ESQ_SUP_DER
	CALL ESCRIBE_CARACTER
	CALL DALE_ENTER
	POP DX
	POP CX
	RET
PARTE_SUPERIOR ENDP
PUBLIC PARTE_INFERIOR
PARTE_INFERIOR PROC
	PUSH CX
	PUSH DX
	MOV DL, ESQ_INF_IZQ
	CALL ESCRIBE_CARACTER
	MOV CX, 49;20
	MOV DL, BARRA_HORIZ
	CICLO:
	CALL ESCRIBE_CARACTER
	LOOP CICLO
	MOV DL, T_INFERIOR
	CALL ESCRIBE_CARACTER
	MOV CX, 18;20
	MOV DL, BARRA_HORIZ
	CICLO2:
	CALL ESCRIBE_CARACTER;309149132
	LOOP CICLO2
	MOV DL, ESQ_INF_DER
	CALL ESCRIBE_CARACTER
	POP DX
	POP CX
	RET
PARTE_INFERIOR ENDP
END
