.MODEL SMALL
.CODE
	MOV DL, 3FH
	MOV DH, DL; CON LAS DOS PRIMERAS LINEAS LOGRAMOS TENER EL NUMERO HEXADECIMAL 3F3F EN EL REGISTRO DX
	MOV CX, 4H; EL REGISTRO CX VA A CONTENER UN NUMERO 4 PORQUE QUEREMOS RECORRER A LA DERECHA CUATRO VECES CON LA LINEA SIGUIENTE
	SHR DL, CL; SHR SIGNIFICA SHIFT RIGHT CAMBIO A LA DERECHA, O RECORRER A LA DERECHA TANTAS VECES COMO LAS QUE INDICA CL (O SEA 4)
	CMP DL, 10; SE COMPARA LO QUE TIENE DL AHORITA (3F) CON EL NUMERO 10 DECIMAL (PORQUE SI NO LE PONES UNA "H" AL FINAL ENTONCES ES DECIMAL)
	JAE HEX_LETTER; JAE SIGNIFICA JUMPAFTEROREQUAL O SEA SALTA SI ES MAYOR O IGUAL (SIN SIGNO)
	ADD DL, "0"; SI NO SE EJECUTA EL SALTO ES PORQUE EL NUMERO ES MENOR QUE NUEVE Y SI ES MENOR ENTONCES SE LE SUMAN 30H TAMBIEN CONOCIDO COMO CODIGO ASCII DEL "0"
	JMP SHORT WRITE_DIGIT; SALTO INCONDICIONAL. SALTA PORQUE SALTA. FORZOSAMENTE.
HEX_LETTER:
	ADD DL, "A"-10; PARA QUE NO TE COMPLIQUES ESTO ES UN 37 HEXADECIMAL. ESTO DICE SUMALE 37H A DL. 41H - 10 = 37H
WRITE_DIGIT:
	CALL WRITE_CHAR
	MOV DL, DH; CON ESTA LINEA RECUPERAS LA INFORMACION QUE PERDISTE EN DL. PORQUE LA ESTAS COPIANDO Y PEGANDO DESDE DH.
	AND DL, 0FH; CUANDO HACES AND CON 0F ESTAS DICIENDO QUE QUIERES QUE EL PRIMER DIGITO QUEDE EN CEROS Y EL SEGUNDO SE VUELVE UN REFLEJO DE LO QUE YA ES
	CMP DL, 10; COMPARAS DE NUEVO CON 10 DECIMAL
	JAE HEX_LETTER1; SI ES MAYOR O IGUAL (LO ES) SALTA A LA ETIQUETA
	ADD DL, "0"
	JMP SHORT WRITE_DIGIT2
HEX_LETTER1:
	ADD DL, "A"-10; ENTONCES CUANDO YA SALTO PARA ACA LE SUMA 37H A LO QUE HAYA EN DL. EN ESTE CASO COMO HABIA UN 15 DECIMAL (LA F) OBTIENES 46H (ASCII DE LA "F")
WRITE_DIGIT2:
	CALL WRITE_CHAR
.EXIT
	PUBLIC WRITE_CHAR
	WRITE_CHAR PROC
	PUSH AX
	MOV AH, 02
	INT 21H
	POP AX
	RET
	WRITE_CHAR ENDP
	COMMENT!
	AUTOR: RICARDO MUÑOZ BOLAÑOS
	!
END 
